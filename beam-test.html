<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¦ å…‰æŸæ•ˆæœæµ‹è¯•é¡µé¢</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            height: fit-content;
        }
        .preview {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .control-group input[type="number"] {
            width: 100%;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        .value-display {
            font-size: 12px;
            color: #ccc;
        }
        #canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            max-width: 100%;
            background: #000;
        }
        .button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        .button:hover {
            transform: translateY(-2px);
        }
        .coordinates {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        h3 {
            margin-top: 0;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <h1>ğŸ”¦ å…‰æŸæ•ˆæœæµ‹è¯•é¡µé¢</h1>
    
    <div class="container">
        <div class="controls">
            <h3>å…‰æŸå‚æ•°è°ƒæ•´</h3>
            
            <div class="control-group">
                <label for="centerOpacity">ä¸­å¿ƒé€æ˜åº¦</label>
                <input type="range" id="centerOpacity" min="0" max="1" step="0.01" value="1">
                <div class="value-display">å€¼: <span id="centerOpacityValue">1</span></div>
            </div>
            
            <div class="control-group">
                <label for="edgeOpacity">è¾¹ç¼˜é€æ˜åº¦</label>
                <input type="range" id="edgeOpacity" min="0" max="1" step="0.01" value="0">
                <div class="value-display">å€¼: <span id="edgeOpacityValue">0</span></div>
            </div>
            
            <div class="control-group">
                <label for="blurRadius">æ¨¡ç³ŠåŠå¾„</label>
                <input type="range" id="blurRadius" min="0" max="50" step="1" value="25">
                <div class="value-display">å€¼: <span id="blurRadiusValue">25</span>px</div>
            </div>
            
            <div class="control-group">
                <label for="beamWidth">å…‰æŸå®½åº¦æ¯”ä¾‹</label>
                <input type="range" id="beamWidth" min="0.1" max="2" step="0.1" value="1">
                <div class="value-display">å€¼: <span id="beamWidthValue">1</span></div>
            </div>
            
            <div class="control-group">
                <label for="globalAlpha">æ•´ä½“é€æ˜åº¦</label>
                <input type="range" id="globalAlpha" min="0" max="1" step="0.01" value="0.4">
                <div class="value-display">å€¼: <span id="globalAlphaValue">0.4</span></div>
            </div>
            
            <div class="control-group">
                <label for="fadeSpeed">é€æ˜åº¦å˜åŒ–é€Ÿåº¦</label>
                <input type="range" id="fadeSpeed" min="0.1" max="5" step="0.1" value="1">
                <div class="value-display">å€¼: <span id="fadeSpeedValue">1</span> (1=çº¿æ€§, >1=å¿«é€Ÿè¡°å‡, <1=ç¼“æ…¢è¡°å‡)</div>
            </div>
            
            <h3>æ¢¯å½¢åæ ‡</h3>
            <div class="control-group">
                <label for="topWidth">é¡¶éƒ¨å®½åº¦</label>
                <input type="number" id="topWidth" value="200" min="50" max="500">
            </div>
            
            <div class="control-group">
                <label for="bottomWidth">åº•éƒ¨å®½åº¦</label>
                <input type="number" id="bottomWidth" value="400" min="100" max="800">
            </div>
            
            <div class="control-group">
                <label for="trapezoidHeight">æ¢¯å½¢é«˜åº¦</label>
                <input type="number" id="trapezoidHeight" value="600" min="200" max="1000">
            </div>
            
            <div class="control-group">
                <label for="offsetY">å‚ç›´åç§»</label>
                <input type="number" id="offsetY" value="100" min="0" max="300">
            </div>
            
            <button class="button" onclick="generateBeam()">ğŸ”„ é‡æ–°ç”Ÿæˆå…‰æŸ</button>
            <button class="button" onclick="downloadBeam()">ğŸ’¾ ä¸‹è½½å…‰æŸå›¾</button>
            <button class="button" onclick="loadAnnotatedData().then(() => generateBeam())">ğŸ“¥ é‡æ–°åŠ è½½æ ‡æ³¨æ•°æ®</button>
            <button class="button" onclick="resetParams()">ğŸ”„ é‡ç½®å‚æ•°</button>
            
            <div class="coordinates">
                <strong>å½“å‰åæ ‡:</strong>
                <div id="coordinatesDisplay"></div>
                <div style="margin-top: 10px; font-size: 11px; color: #aaa;">
                    ğŸ’¡ ä¼˜å…ˆä½¿ç”¨ beam-data.json ä¸­çš„ç”¨æˆ·æ ‡æ³¨æ•°æ®<br>
                    å¦‚æ— æ ‡æ³¨æ•°æ®åˆ™ä½¿ç”¨ä¸Šæ–¹æ¢¯å½¢å‚æ•°
                </div>
            </div>
        </div>
        
        <div class="preview">
            <h3>å…‰æŸé¢„è§ˆ</h3>
            <canvas id="canvas" width="540" height="960"></canvas>
            <div style="margin-top: 10px; font-size: 14px; color: #ccc;">
                ç”»å¸ƒå°ºå¯¸: 540 Ã— 960 (æ¨¡æ‹Ÿæ‰‹æœºå±å¹•æ¯”ä¾‹)
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // è·å–æ‰€æœ‰æ§ä»¶
        const controls = {
            centerOpacity: document.getElementById('centerOpacity'),
            edgeOpacity: document.getElementById('edgeOpacity'),
            blurRadius: document.getElementById('blurRadius'),
            beamWidth: document.getElementById('beamWidth'),
            globalAlpha: document.getElementById('globalAlpha'),
            fadeSpeed: document.getElementById('fadeSpeed'),
            topWidth: document.getElementById('topWidth'),
            bottomWidth: document.getElementById('bottomWidth'),
            trapezoidHeight: document.getElementById('trapezoidHeight'),
            offsetY: document.getElementById('offsetY')
        };
        
        // æ›´æ–°æ˜¾ç¤ºå€¼
        function updateDisplayValues() {
            document.getElementById('centerOpacityValue').textContent = controls.centerOpacity.value;
            document.getElementById('edgeOpacityValue').textContent = controls.edgeOpacity.value;
            document.getElementById('blurRadiusValue').textContent = controls.blurRadius.value;
            document.getElementById('beamWidthValue').textContent = controls.beamWidth.value;
            document.getElementById('globalAlphaValue').textContent = controls.globalAlpha.value;
            document.getElementById('fadeSpeedValue').textContent = controls.fadeSpeed.value;
        }
        
        // ç”¨æˆ·æ ‡æ³¨æ•°æ®
        let annotatedData = null;
        
        // åŠ è½½ç”¨æˆ·æ ‡æ³¨æ•°æ®
        async function loadAnnotatedData() {
            try {
                const response = await fetch('/beam-data.json');
                if (response.ok) {
                    annotatedData = await response.json();
                    console.log('âœ… åŠ è½½ç”¨æˆ·æ ‡æ³¨æ•°æ®:', annotatedData);
                    updateControlsFromAnnotatedData();
                    return true;
                }
            } catch (error) {
                console.log('âš ï¸ æ— æ³•åŠ è½½æ ‡æ³¨æ•°æ®ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°:', error);
            }
            return false;
        }
        
        // æ ¹æ®æ ‡æ³¨æ•°æ®æ›´æ–°æ§ä»¶
        function updateControlsFromAnnotatedData() {
            if (!annotatedData || !annotatedData.polygon) return;
            
            // ç¼©æ”¾æ ‡æ³¨æ•°æ®åˆ°å½“å‰ç”»å¸ƒå°ºå¯¸
            const scaleX = canvas.width / annotatedData.width;
            const scaleY = canvas.height / annotatedData.height;
            
            // è®¡ç®—ç¼©æ”¾åçš„åæ ‡
            const scaledPolygon = annotatedData.polygon.map(point => ({
                x: Math.round(point.x * scaleX),
                y: Math.round(point.y * scaleY)
            }));
            
            // æ›´æ–°åæ ‡æ˜¾ç¤º
            const coordText = scaledPolygon.map((coord, i) => 
                `ç‚¹${i+1}: (${coord.x}, ${coord.y})`
            ).join('\n');
            document.getElementById('coordinatesDisplay').innerHTML = 
                `<strong>ç”¨æˆ·æ ‡æ³¨åæ ‡ (å·²ç¼©æ”¾):</strong><br>${coordText.replace(/\n/g, '<br>')}`;
        }
        
        // è®¡ç®—åæ ‡ï¼ˆä¼˜å…ˆä½¿ç”¨æ ‡æ³¨æ•°æ®ï¼‰
        function calculateCoordinates() {
            if (annotatedData && annotatedData.polygon) {
                // ä½¿ç”¨æ ‡æ³¨æ•°æ®
                const scaleX = canvas.width / annotatedData.width;
                const scaleY = canvas.height / annotatedData.height;
                
                const coordinates = annotatedData.polygon.map(point => [
                    Math.round(point.x * scaleX),
                    Math.round(point.y * scaleY)
                ]);
                
                updateControlsFromAnnotatedData();
                return coordinates;
            } else {
                // ä½¿ç”¨æ¢¯å½¢å‚æ•°
                const topWidth = parseInt(controls.topWidth.value);
                const bottomWidth = parseInt(controls.bottomWidth.value);
                const height = parseInt(controls.trapezoidHeight.value);
                const offsetY = parseInt(controls.offsetY.value);
                
                const centerX = canvas.width / 2;
                const startY = offsetY;
                const endY = startY + height;
                
                const coordinates = [
                    [centerX - topWidth/2, startY],      // å·¦ä¸Š
                    [centerX + topWidth/2, startY],      // å³ä¸Š
                    [centerX + bottomWidth/2, endY],     // å³ä¸‹
                    [centerX - bottomWidth/2, endY]      // å·¦ä¸‹
                ];
                
                // æ›´æ–°åæ ‡æ˜¾ç¤º
                const coordText = coordinates.map((coord, i) => 
                    `${['å·¦ä¸Š', 'å³ä¸Š', 'å³ä¸‹', 'å·¦ä¸‹'][i]}: (${coord[0]}, ${coord[1]})`
                ).join('\n');
                document.getElementById('coordinatesDisplay').textContent = coordText;
                
                return coordinates;
            }
        }
        
        // åˆ›å»ºå¤šè¾¹å½¢è·¯å¾„
         function createPolygonPath(coordinates) {
             const path = new Path2D();
             path.moveTo(coordinates[0][0], coordinates[0][1]);
             for (let i = 1; i < coordinates.length; i++) {
                 path.lineTo(coordinates[i][0], coordinates[i][1]);
             }
             path.closePath();
             return path;
         }
        
        // ç”Ÿæˆå…‰æŸæ•ˆæœ
        function generateBeam() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è·å–å‚æ•°
            const centerOpacity = parseFloat(controls.centerOpacity.value);
            const edgeOpacity = parseFloat(controls.edgeOpacity.value);
            const blurRadius = parseInt(controls.blurRadius.value);
            const beamWidth = parseFloat(controls.beamWidth.value);
            const globalAlpha = parseFloat(controls.globalAlpha.value);
            
            // è®¡ç®—åæ ‡ï¼ˆä¼˜å…ˆä½¿ç”¨æ ‡æ³¨æ•°æ®ï¼‰
             const coordinates = calculateCoordinates();
             
             // åˆ›å»ºå¤šè¾¹å½¢è£åˆ‡è·¯å¾„
             const polygonPath = createPolygonPath(coordinates);
            
            // ä¿å­˜å½“å‰çŠ¶æ€
            ctx.save();
            
            // ä¸åº”ç”¨å¤šè¾¹å½¢è£åˆ‡ï¼Œä¿æŒå®Œæ•´å›¾ç‰‡
            console.log('ğŸ–¼ï¸ é¢„è§ˆæ¨¡å¼ï¼šä¸åº”ç”¨å¤šè¾¹å½¢è£åˆ‡ï¼Œæ˜¾ç¤ºå®Œæ•´å›¾ç‰‡');
            
            // è·å–é€æ˜åº¦å˜åŒ–é€Ÿåº¦å‚æ•°
            const fadeSpeed = parseFloat(controls.fadeSpeed.value);
            
            // åˆ›å»ºè‡ªå®šä¹‰æ¸å˜å…‰æŸ
            const centerX = canvas.width / 2;
            const beamWidthPixels = canvas.width * beamWidth;
            const startX = centerX - beamWidthPixels / 2;
            const endX = centerX + beamWidthPixels / 2;
            
            // åˆ›å»ºæ¸å˜ï¼Œä½¿ç”¨æ›´å¤šçš„è‰²æ ‡æ¥å®ç°éçº¿æ€§æ•ˆæœ
            const gradient = ctx.createLinearGradient(startX, 0, endX, 0);
            
            // ç”Ÿæˆå¤šä¸ªè‰²æ ‡ç‚¹æ¥æ¨¡æ‹Ÿéçº¿æ€§æ¸å˜
            const steps = 20; // æ¸å˜æ­¥æ•°
            for (let i = 0; i <= steps; i++) {
                const position = i / steps; // 0 åˆ° 1
                let opacity;
                
                if (position <= 0.5) {
                    // ä»è¾¹ç¼˜åˆ°ä¸­å¿ƒ (0 åˆ° 0.5)
                    const normalizedPos = position * 2; // 0 åˆ° 1
                    const easedPos = Math.pow(normalizedPos, 1 / fadeSpeed); // åº”ç”¨ç¼“åŠ¨
                    opacity = edgeOpacity + (centerOpacity - edgeOpacity) * easedPos;
                } else {
                    // ä»ä¸­å¿ƒåˆ°è¾¹ç¼˜ (0.5 åˆ° 1)
                    const normalizedPos = (1 - position) * 2; // 1 åˆ° 0
                    const easedPos = Math.pow(normalizedPos, 1 / fadeSpeed); // åº”ç”¨ç¼“åŠ¨
                    opacity = edgeOpacity + (centerOpacity - edgeOpacity) * easedPos;
                }
                
                gradient.addColorStop(position, `rgba(255, 255, 255, ${opacity})`);
            }
            
            // ç»˜åˆ¶åŸºç¡€å…‰æŸ
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // åº”ç”¨æ¨¡ç³Šæ•ˆæœï¼ˆæ¨¡æ‹Ÿé«˜æ–¯æ¨¡ç³Šï¼‰
            if (blurRadius > 0) {
                ctx.filter = `blur(${blurRadius}px)`;
                ctx.globalAlpha = globalAlpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // æ¢å¤çŠ¶æ€
            ctx.restore();
            
            // ç»˜åˆ¶å¤šè¾¹å½¢è¾¹æ¡†ï¼ˆç”¨äºè°ƒè¯•ï¼‰
             ctx.save();
             ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
             ctx.lineWidth = 2;
             ctx.stroke(polygonPath);
             ctx.restore();
        }
        
        // ä¸‹è½½å…‰æŸå›¾
        function downloadBeam() {
            // åˆ›å»ºä¸€ä¸ªæ–°çš„canvasç”¨äºå¯¼å‡ºï¼ˆä¸åŒ…å«è°ƒè¯•è¾¹æ¡†ï¼‰
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // é‡æ–°ç»˜åˆ¶å…‰æŸï¼ˆä¸åŒ…å«è¾¹æ¡†ï¼‰
            const centerOpacity = parseFloat(controls.centerOpacity.value);
            const edgeOpacity = parseFloat(controls.edgeOpacity.value);
            const blurRadius = parseInt(controls.blurRadius.value);
            const beamWidth = parseFloat(controls.beamWidth.value);
            const globalAlpha = parseFloat(controls.globalAlpha.value);
            
            const coordinates = calculateCoordinates();
             const polygonPath = createPolygonPath(coordinates);
            
            exportCtx.save();
            // ä¸åº”ç”¨å¤šè¾¹å½¢è£åˆ‡ï¼Œä¿æŒå®Œæ•´å›¾ç‰‡
            console.log('ğŸ–¼ï¸ å¯¼å‡ºæ¨¡å¼ï¼šä¸åº”ç”¨å¤šè¾¹å½¢è£åˆ‡ï¼Œæ˜¾ç¤ºå®Œæ•´å›¾ç‰‡');
            
            const fadeSpeed = parseFloat(controls.fadeSpeed.value);
            
            const centerX = canvas.width / 2;
            const beamWidthPixels = canvas.width * beamWidth;
            const startX = centerX - beamWidthPixels / 2;
            const endX = centerX + beamWidthPixels / 2;
            
            const gradient = exportCtx.createLinearGradient(startX, 0, endX, 0);
            
            // ç”Ÿæˆå¤šä¸ªè‰²æ ‡ç‚¹æ¥æ¨¡æ‹Ÿéçº¿æ€§æ¸å˜ï¼ˆä¸é¢„è§ˆä¿æŒä¸€è‡´ï¼‰
            const steps = 20;
            for (let i = 0; i <= steps; i++) {
                const position = i / steps;
                let opacity;
                
                if (position <= 0.5) {
                    const normalizedPos = position * 2;
                    const easedPos = Math.pow(normalizedPos, 1 / fadeSpeed);
                    opacity = edgeOpacity + (centerOpacity - edgeOpacity) * easedPos;
                } else {
                    const normalizedPos = (1 - position) * 2;
                    const easedPos = Math.pow(normalizedPos, 1 / fadeSpeed);
                    opacity = edgeOpacity + (centerOpacity - edgeOpacity) * easedPos;
                }
                
                gradient.addColorStop(position, `rgba(255, 255, 255, ${opacity})`);
            }
            
            exportCtx.fillStyle = gradient;
            exportCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (blurRadius > 0) {
                exportCtx.filter = `blur(${blurRadius}px)`;
                exportCtx.globalAlpha = globalAlpha;
                exportCtx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            exportCtx.restore();
            
            // ä¸‹è½½å›¾ç‰‡
            const link = document.createElement('a');
            link.download = `trapezoid_beam_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL();
            link.click();
        }
        
        // é‡ç½®å‚æ•°
        function resetParams() {
            controls.centerOpacity.value = 1;
            controls.edgeOpacity.value = 0;
            controls.blurRadius.value = 25;
            controls.beamWidth.value = 1;
            controls.globalAlpha.value = 0.4;
            controls.fadeSpeed.value = 1;
            controls.topWidth.value = 200;
            controls.bottomWidth.value = 400;
            controls.trapezoidHeight.value = 600;
            controls.offsetY.value = 100;
            
            updateDisplayValues();
            generateBeam();
        }
        
        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        Object.values(controls).forEach(control => {
            control.addEventListener('input', () => {
                updateDisplayValues();
                generateBeam();
            });
        });
        
        // åˆå§‹åŒ–
         async function initialize() {
             updateDisplayValues();
             await loadAnnotatedData();
             generateBeam();
         }
         
         // å¯åŠ¨åˆå§‹åŒ–
         initialize();
    </script>
</body>
</html>